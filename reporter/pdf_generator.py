"""
PDF Report Generator
Production-ready PDF generation with error handling
"""

try:
    from fpdf import FPDF
except ImportError:
    raise ImportError(
        "FPDF not found. Please install using: pip install fpdf2\n"
        "Note: The package name is fpdf2 but we import from fpdf"
    )

from datetime import datetime
from pathlib import Path
from typing import Optional
from config import Config
from utils.logger import logger

class JobReportPDF(FPDF):
    """Custom PDF report class"""
    
    def __init__(self):
        super().__init__()
        self.set_auto_page_break(auto=True, margin=15)
    
    def header(self):
        """Custom header"""
        self.set_font('Arial', 'B', 20)
        self.set_text_color(0, 102, 204)
        self.cell(0, 15, 'Upwork Job Analysis Report', 0, 1, 'C')
        
        self.set_font('Arial', 'I', 10)
        self.set_text_color(100, 100, 100)
        self.cell(0, 5, datetime.now().strftime('%d %B %Y, %I:%M %p IST'), 0, 1, 'C')
        
        self.ln(10)
        self.set_draw_color(0, 102, 204)
        self.line(10, self.get_y(), 200, self.get_y())
        self.ln(5)
    
    def footer(self):
        """Custom footer"""
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.set_text_color(128, 128, 128)
        self.cell(0, 10, f'Page {self.page_no()}/{{nb}} | Generated by Upwork Job Analyzer', 0, 0, 'C')
    
    def chapter_title(self, title: str):
        """Add chapter title"""
        self.set_font('Arial', 'B', 14)
        self.set_text_color(0, 0, 0)
        self.set_fill_color(230, 240, 250)
        self.cell(0, 10, title, 0, 1, 'L', True)
        self.ln(3)
    
    def chapter_body(self, body: str):
        """Add chapter body"""
        self.set_font('Arial', '', 10)
        self.set_text_color(50, 50, 50)
        self.multi_cell(0, 5, body)
        self.ln()

class PDFReportGenerator:
    """PDF report generator with error handling"""
    
    def __init__(self):
        self.config = Config
    
    def generate_report(self, analysis_text: str, job_count: int, 
                       metadata: Optional[dict] = None) -> Optional[str]:
        """
        Generate PDF report
        
        Args:
            analysis_text: Analysis from Gemini
            job_count: Number of jobs analyzed
            metadata: Additional metadata
            
        Returns:
            PDF filename if successful, None otherwise
        """
        try:
            logger.info("ðŸ“„ Generating PDF report...")
            
            pdf = JobReportPDF()
            pdf.alias_nb_pages()
            pdf.add_page()
            
            # Summary section
            pdf.chapter_title("Executive Summary")
            summary = f"Total Jobs Analyzed: {job_count}\n"
            summary += f"Analysis Date: {datetime.now().strftime('%d %B %Y')}\n"
            summary += f"Search Query: {self.config.SEARCH_QUERY}\n"
            
            if metadata:
                summary += f"Pages Scraped: {metadata.get('pages', 'N/A')}\n"
                summary += f"Valid Jobs: {metadata.get('valid_jobs', 'N/A')}\n"
            
            pdf.chapter_body(summary)
            
            # Clean and format analysis text
            clean_text = self._clean_text(analysis_text)
            
            # Parse sections
            sections = self._parse_sections(clean_text)
            
            # Add each section
            for title, content in sections:
                pdf.chapter_title(title)
                pdf.chapter_body(content)
            
            # Save PDF
            filename = self._get_filename()
            pdf.output(str(filename))
            
            logger.info(f"âœ… PDF saved: {filename}")
            return str(filename)
        
        except Exception as e:
            logger.error(f"PDF generation error: {e}")
            return self._generate_text_fallback(analysis_text, job_count)
    
    def _clean_text(self, text: str) -> str:
        """Clean text for PDF"""
        # Remove emojis and special characters
        text = text.encode('ascii', 'ignore').decode('ascii')
        # Remove markdown symbols
        text = text.replace('##', '').replace('**', '').replace('*', '')
        return text
    
    def _parse_sections(self, text: str) -> list:
        """Parse text into sections"""
        sections = []
        current_title = "Analysis"
        current_content = []
        
        lines = text.split('\n')
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            # Check if line is a section header
            if line.isupper() or (len(line) < 100 and line.endswith(':')):
                # Save previous section
                if current_content:
                    sections.append((current_title, '\n'.join(current_content)))
                    current_content = []
                
                current_title = line.rstrip(':')
            else:
                current_content.append(line)
        
        # Add last section
        if current_content:
            sections.append((current_title, '\n'.join(current_content)))
        
        return sections
    
    def _get_filename(self) -> Path:
        """Generate unique filename"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = self.config.REPORTS_DIR / f"upwork_report_{timestamp}.pdf"
        return filename
    
    def _generate_text_fallback(self, analysis_text: str, job_count: int) -> Optional[str]:
        """Generate text file as fallback"""
        try:
            logger.warning("âš ï¸  Falling back to text report")
            
            filename = self.config.REPORTS_DIR / f"upwork_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            
            with open(filename, 'w', encoding='utf-8') as f:
                f.write("=" * 60 + "\n")
                f.write("UPWORK JOB ANALYSIS REPORT\n")
                f.write("=" * 60 + "\n\n")
                f.write(f"Date: {datetime.now().strftime('%d %B %Y, %I:%M %p IST')}\n")
                f.write(f"Total Jobs: {job_count}\n")
                f.write(f"Search Query: {self.config.SEARCH_QUERY}\n")
                f.write("\n" + "=" * 60 + "\n\n")
                f.write(analysis_text)
            
            logger.info(f"âœ… Text report saved: {filename}")
            return str(filename)
        
        except Exception as e:
            logger.error(f"Text fallback error: {e}")
            return None

# Global generator instance
pdf_generator = PDFReportGenerator()

def generate_pdf_report(analysis_text: str, job_count: int, 
                       metadata: Optional[dict] = None) -> Optional[str]:
    """Main PDF generation function"""
    return pdf_generator.generate_report(analysis_text, job_count, metadata)
